async function animateGraph() {

    // 描画領域をリセット
    ctx.fillStyle = 'rgb(0, 0, 0)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // 3軸の描画
    Axis();

    // 2つの初期点から解軌道を描くために、配列に要素をセットする
    for (let i = 0; i < 2; i++) {
        linePoints.push([]);
    }

    var dt = 0.0;
    var dnt = 0.0;

    // Runge-Kutta法
    var Ru_dx = new Array(2);
    var Ru_dy = new Array(2);
    var Ru_dz = new Array(2);
    var Ru_x0 = 0.0;
    var Ru_y0 = 0.0;
    var Ru_z0 = 0.0;
    var Ru_x0_init = new Array(2);   // 初期値
    var Ru_y0_init = new Array(2);
    var Ru_kx = new Array(4);
    var Ru_ky = new Array(4);
    var Ru_kz = new Array(4);

    let pixelX;
    let pixelY;

    let vx1 = 0.0, vy1 = 0.0, vz1 = 0.0, vx2 = 0.0, vy2 = 0.0, vz2 = 0.0;
    let obj1 = {x3: vx1, y3: vy1, z3: vz1};
    let obj2 = {x3: vx2, y3: vy2, z3: vz2};

    //// for debug start
    Ru_dx[0] = init1[0];
    Ru_dy[0] = init1[1];
    Ru_dz[0] = init1[2];
    Ru_dx[1] = init2[0];
    Ru_dy[1] = init2[1];
    Ru_dz[1] = init2[2];
    //// for debug   end

    for (dp = 1; dp <= cnt_dp; dp++) {
        for (let i = 0; i < 2; i++) {

            Ru_x0 = Ru_dx[i];
            Ru_y0 = Ru_dy[i];
            Ru_z0 = Ru_dz[i];

            if (i % 2 == 0) { // 20231229 dtのカウントが2倍で効いていたバグを修正
                dt = dnt;
            }

            if (dp == 1) {
                R3D(Ru_x0, Ru_y0, Ru_z0, obj1);

                pixelX = scaleX * (obj1.x + width0 / 2);
                pixelY = scaleY * (height0 / 2 - obj1.y);
                linePoints[i].push({ x: pixelX, y: pixelY });
            }

            ///////////////////
            //               //
            // Runge-Kutta法 //
            //               //
            ///////////////////

            Ru_kx[0] = dh * FNF(dt, Ru_x0, Ru_y0, Ru_z0);
            Ru_ky[0] = dh * FNG(dt, Ru_x0, Ru_y0, Ru_z0);
            Ru_kz[0] = dh * FNH(dt, Ru_x0, Ru_y0, Ru_z0);
            Ru_kx[1] = dh * FNF(dt + dh / 2.0, Ru_x0 + Ru_kx[0] / 2.0, Ru_y0 + Ru_ky[0] / 2.0, Ru_z0 + Ru_kz[0] / 2.0);
            Ru_ky[1] = dh * FNG(dt + dh / 2.0, Ru_x0 + Ru_kx[0] / 2.0, Ru_y0 + Ru_ky[0] / 2.0, Ru_z0 + Ru_kz[0] / 2.0);
            Ru_kz[1] = dh * FNH(dt + dh / 2.0, Ru_x0 + Ru_kx[0] / 2.0, Ru_y0 + Ru_ky[0] / 2.0, Ru_z0 + Ru_kz[0] / 2.0);
            Ru_kx[2] = dh * FNF(dt + dh / 2.0, Ru_x0 + Ru_kx[1] / 2.0, Ru_y0 + Ru_ky[1] / 2.0, Ru_z0 + Ru_kz[1] / 2.0);
            Ru_ky[2] = dh * FNG(dt + dh / 2.0, Ru_x0 + Ru_kx[1] / 2.0, Ru_y0 + Ru_ky[1] / 2.0, Ru_z0 + Ru_kz[1] / 2.0);
            Ru_kz[2] = dh * FNH(dt + dh / 2.0, Ru_x0 + Ru_kx[1] / 2.0, Ru_y0 + Ru_ky[1] / 2.0, Ru_z0 + Ru_kz[1] / 2.0);
            Ru_kx[3] = dh * FNF(dt + dh, Ru_x0 + Ru_kx[2], Ru_y0 + Ru_ky[2], Ru_z0 + Ru_kz[2]);
            Ru_ky[3] = dh * FNG(dt + dh, Ru_x0 + Ru_kx[2], Ru_y0 + Ru_ky[2], Ru_z0 + Ru_kz[2]);
            Ru_kz[3] = dh * FNH(dt + dh, Ru_x0 + Ru_kx[2], Ru_y0 + Ru_ky[2], Ru_z0 + Ru_kz[2]);

            Ru_dx[i] = Ru_x0 + (Ru_kx[0] + 2.0 * Ru_kx[1] + 2.0 * Ru_kx[2] + Ru_kx[3]) / 6.0;
            Ru_dy[i] = Ru_y0 + (Ru_ky[0] + 2.0 * Ru_ky[1] + 2.0 * Ru_ky[2] + Ru_ky[3]) / 6.0;
            Ru_dz[i] = Ru_z0 + (Ru_kz[0] + 2.0 * Ru_kz[1] + 2.0 * Ru_kz[2] + Ru_kz[3]) / 6.0;

            if (i % 2 == 0)
            {
                dnt = dt + dh;
            }

            //////////
            //      //
            // 描画 //
            //      //
            //////////

            if (i == 0) {
                R3D(Ru_dx[i], Ru_dy[i], Ru_dz[i], obj2);

                pixelX = scaleX * (obj2.x3 + width0 / 2);
                pixelY = scaleY * (height0 / 2 - obj2.y3);

                linePoints[i].push({ x: pixelX, y: pixelY });

                ctx.beginPath();
                ctx.moveTo(linePoints[i][0].x, linePoints[i][0].y);
                for (const point of linePoints[i]) {
                    ctx.lineTo(point.x, point.y);
                }
                ctx.strokeStyle = 'rgb(100, 149, 237)';
                ctx.stroke();

                // Draw the point
                ctx.beginPath();
                ctx.arc(pixelX, pixelY, 2, 0, 2 * Math.PI);
                ctx.fillStyle = 'orange';
                ctx.fill();
            }

            if (i == 1) {
                R3D(Ru_dx[i], Ru_dy[i], Ru_dz[i], obj2);

                pixelX = scaleX * (obj2.x3 + width0 / 2);
                pixelY = scaleY * (height0 / 2 - obj2.y3);

                linePoints[i].push({ x: pixelX, y: pixelY });

                ctx.beginPath();
                ctx.moveTo(linePoints[i][0].x, linePoints[i][0].y);
                for (const point of linePoints[i]) {
                    ctx.lineTo(point.x, point.y);
                }
                ctx.strokeStyle = 'rgb(200, 200, 55)';
                ctx.stroke();

                // Draw the point
                ctx.beginPath();
                ctx.arc(pixelX, pixelY, 2, 0, 2 * Math.PI);
                ctx.fillStyle = 'red';
                ctx.fill();
            }
        }
        if (dp % 100 == 0 || dp == cnt_dp - 1) // 描画リフレッシュステップ
        {
            if (dp != cnt_dp) {
                // 描画領域をリセット
                ctx.fillStyle = 'rgb(0, 0, 0)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }
        if (dp % 1 == 0) { // 倍速設定
            await new Promise(resolve => setTimeout(resolve, 20)); // Wait for 20 milliseconds
        }
    }
}