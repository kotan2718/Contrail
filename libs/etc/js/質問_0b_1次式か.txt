htmlとjavascriptについての質問です。

htmlに微分方程式を入力できるフォームを配置します。
入力された方程式はjs側で文字列データとした上で
math.jsで数式として評価され、結果としてhtmlのページにグラフがプロットされます。

htmlで方程式を入力するフォームは以下の通りです。
(パラメーターtを用いた連立微分方程式です)

<p class="pb10 input-container">
    <label id="l_dxdt">$dx / dt = $</label>
    <!--<textarea id="dxdt" cols="30" rows="2">x + 2*y</textarea>-->
    <!--<textarea id="dxdt" cols="30" rows="2">1</textarea>-->
    <!--<textarea id="dxdt" cols="30" rows="2">1</textarea>-->
    <textarea id="dxdt" cols="30" rows="2">x^2 * (y - x) + y^5</textarea>
    <!--<textarea id="dxdt" cols="30" rows="2">cos(x) + cos(y)</textarea>-->
    <!--<textarea id="dxdt" cols="30" rows="2">cos(x) + cos(y)</textarea>-->
    <!--<textarea id="dxdt" cols="30" rows="2">-y + 10 * x * exp(-1 / sqrt(r)) * sin(1 / r)</textarea>-->
</p>
<p class="pb10 input-container">
    <label id="l_dydt">$dy / dt = $</label>
    <!--<textarea id="dydt" cols="30" rows="2">-x - y</textarea>-->
    <!--<textarea id="dydt" cols="30" rows="2">2*y / x</textarea>-->
    <!--<textarea id="dydt" cols="30" rows="2">e^x - y</textarea>-->
    <textarea id="dydt" cols="30" rows="2">y^2 * (y - 2 * x)</textarea>
    <!--<textarea id="dydt" cols="30" rows="2">sin(x) * sin(y)</textarea>-->
    <!--<textarea id="dydt" cols="30" rows="2">x + 10 * y * exp(-1 / sqrt(r)) * sin(1 / r)</textarea>-->
</p>

この場合、コメントアウトしていない行は、js側で文字列として
変数formula_dxに"x^2 * (y - x) + y^5"、
変数formula_dyに"y^2 * (y - 2 * x)"
に格納されます。

グラフは連立微分方程式の近似解をプロットするようにプログラムされています。
式の評価は以下の通りです。

math.evaluate(formula_dx, { dt: dt, x: x, y: y });
math.evaluate(formula_dy, { dt: dt, x: x, y: y });


さて、ここからが本題です。
入力された方程式がxとyの1次式(linear)か否かを判定したいのです。
例に挙げた方程式は、当然1次式ではないので「否」です。

自分なりには以下のように考えています。
①
まず、formula_dx、formula_dyの段階で1次式であることを判定する。
これは、場合分けに相当苦労するのではないかと思います。
例えば
"x + x - y - y" と"2*x - 2*y"は同じです。
"x*x" と "x^2"は同じです。
等々...

②
math.evaluateで式として評価された段階で、判定する。
ここでlinearかどうかを判定する方法は思いつきません。

①、②及び、他の方法で判定する方法はあるでしょうか?


回答


連立微分方程式がxとyの1次式（linear）か否かを判定するためには、数式の構造を解析する必要があります。
特に、変数の次数を確認し、非線形項（例えば
x^2, xy, y^2
  など）が存在するかどうかを確認する必要があります。以下はその方法の一つです。

方法 1: Math.js の抽象構文木（AST）を使用する
Math.js は数式の構文解析をサポートしており、数式を抽象構文木（AST: Abstract Syntax Tree）に変換できます。
このASTを解析することで、数式が1次式かどうかを判定できます。

まず、数式を解析してASTに変換する方法を説明します。

html
コードをコピーする
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Differential Equations</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.0.0/math.min.js"></script>
</head>
<body>
    <p class="pb10 input-container">
        <label id="l_dxdt">$dx / dt = $</label>
        <textarea id="dxdt" cols="30" rows="2">x^2 * (y - x) + y^5</textarea>
    </p>
    <p class="pb10 input-container">
        <label id="l_dydt">$dy / dt = $</label>
        <textarea id="dydt" cols="30" rows="2">y^2 * (y - 2 * x)</textarea>
    </p>
    <button onclick="checkLinearity()">Check Linearity</button>
    <p id="result"></p>

    <script>
        function checkLinearity() {
            const formula_dx = document.getElementById('dxdt').value;
            const formula_dy = document.getElementById('dydt').value;

            const isLinear = (expr) => {
                const node = math.parse(expr);
                let linear = true;

                // Function to traverse the AST
                const traverse = (node) => {
                    if (node.type === 'OperatorNode') {
                        if (node.op === '*' || node.op === '/') {
                            node.args.forEach(arg => {
                                if (arg.type === 'SymbolNode' || arg.type === 'ConstantNode') {
                                    // These are fine
                                } else {
                                    // If we encounter a non-linear term, mark as non-linear
                                    linear = false;
                                }
                            });
                        }
                        node.args.forEach(traverse);
                    } else if (node.type === 'FunctionNode') {
                        // Functions (e.g., sin, cos) are non-linear
                        linear = false;
                    } else if (node.type === 'ParenthesisNode') {
                        traverse(node.content);
                    }
                };

                traverse(node);
                return linear;
            };

            const result_dx = isLinear(formula_dx) ? "Linear" : "Non-linear";
            const result_dy = isLinear(formula_dy) ? "Linear" : "Non-linear";

            document.getElementById('result').innerText = `dx/dt: ${result_dx}, dy/dt: ${result_dy}`;
        }
    </script>
</body>
</html>
方法 2: シンボルや多項式の形状を解析する
より具体的な方法として、ASTを解析する際に、各変数の次数を確認します。以下のコードはその概念を示します。

javascript
コードをコピーする
const isLinear = (expr) => {
    const node = math.parse(expr);
    let linear = true;

    const traverse = (node) => {
        if (node.type === 'OperatorNode') {
            if (node.op === '*' || node.op === '/') {
                node.args.forEach(arg => {
                    if (arg.type === 'SymbolNode' || arg.type === 'ConstantNode') {
                        // These are acceptable in a linear expression
                    } else {
                        // Non-linear term detected
                        linear = false;
                    }
                });
            } else if (node.op === '^') {
                const base = node.args[0];
                const exponent = node.args[1];
                if (exponent.type === 'ConstantNode' && exponent.value !== 1) {
                    linear = false;
                }
            }
            node.args.forEach(traverse);
        } else if (node.type === 'FunctionNode') {
            // Functions (e.g., sin, cos) are non-linear
            linear = false;
        } else if (node.type === 'ParenthesisNode') {
            traverse(node.content);
        }
    };

    traverse(node);
    return linear;
};
この方法で数式を解析し、変数が1次式であるかどうかを判定できます。
この例では、演算子ノードと関数ノードを確認し、非線形項があるかどうかを判断しています。

上記のコードを参考にして、微分方程式が線形か非線形かを判定できます。
これにより、連立微分方程式が1次式かどうかを簡単に判定できます。


ありがとうございます。確認してみます。

ChatGPT
どういたしまして！コードを確認して、うまくいくかどうか試してみてください。
もし問題が発生したり、さらなる質問があれば、遠慮なくお知らせください。こちらでサポートさせていただきます。
以下に、もう少し具体的に、数式を解析して1次式かどうかを判定するためのコードをまとめておきます。

HTML
まず、HTML部分はそのまま使用できます。

html
コードをコピーする
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Differential Equations</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.0.0/math.min.js"></script>
</head>
<body>
    <p class="pb10 input-container">
        <label id="l_dxdt">$dx / dt = $</label>
        <textarea id="dxdt" cols="30" rows="2">x^2 * (y - x) + y^5</textarea>
    </p>
    <p class="pb10 input-container">
        <label id="l_dydt">$dy / dt = $</label>
        <textarea id="dydt" cols="30" rows="2">y^2 * (y - 2 * x)</textarea>
    </p>
    <button onclick="checkLinearity()">Check Linearity</button>
    <p id="result"></p>

    <script>
        function checkLinearity() {
            const formula_dx = document.getElementById('dxdt').value;
            const formula_dy = document.getElementById('dydt').value;

            const isLinear = (expr) => {
                const node = math.parse(expr);
                let linear = true;

                const traverse = (node) => {
                    if (node.type === 'OperatorNode') {
                        if (node.op === '*' || node.op === '/') {
                            node.args.forEach(arg => {
                                if (arg.type !== 'SymbolNode' && arg.type !== 'ConstantNode') {
                                    // 非線形項が検出された場合
                                    linear = false;
                                }
                            });
                        } else if (node.op === '^') {
                            const base = node.args[0];
                            const exponent = node.args[1];
                            if (exponent.type === 'ConstantNode' && exponent.value !== 1) {
                                linear = false;
                            }
                        }
                        node.args.forEach(traverse);
                    } else if (node.type === 'FunctionNode') {
                        // 関数 (例: sin, cos) は非線形
                        linear = false;
                    } else if (node.type === 'ParenthesisNode') {
                        traverse(node.content);
                    }
                };

                traverse(node);
                return linear;
            };

            const result_dx = isLinear(formula_dx) ? "Linear" : "Non-linear";
            const result_dy = isLinear(formula_dy) ? "Linear" : "Non-linear";

            document.getElementById('result').innerText = `dx/dt: ${result_dx}, dy/dt: ${result_dy}`;
        }
    </script>
</body>
</html>
説明
HTMLフォーム: dxdt と dydt の入力フィールドを持つフォーム。
JavaScript関数 checkLinearity: ボタンがクリックされたときに呼び出され、入力された数式が線形かどうかを判定します。
isLinear関数: 数式を解析し、線形か非線形かを判定するロジックを実装。
math.parse(expr): 数式をAST（抽象構文木）に変換します。
traverse(node): ASTを再帰的に巡回し、非線形項（乗算、除算、累乗、関数など）があるかどうかをチェックします。
このアプローチを使うと、入力された数式が線形かどうかを簡単に判定できます。
これを基に必要に応じてカスタマイズや追加のチェックを行うことも可能です。質問があれば、いつでもどうぞ！


20240601

ありがとうございます。最後に示して頂いたロジックで、線形か否か判別できることを確認しました。
function checkLinearity()内で
arg.type !== 'ConstantNode'を利用して、線形の場合、xとyの係数を取得することができないでしょうか？
目的とするのは、dx/dt、dy/dtとも線形の場合です。
出てくるパターンとしては
①
dx/dt = ax + by
dy/dt = cx + dy
ここでは、a,b,c,dという文字を使っていますが、実際に入力された式では1とか2.5などの実係数です。
②
dx/dt = ax
dy/dt = dy
③
dx/dt = ax
dy/dt = cx + dy
④
dx/dt = ax + by
dy/dt = dy

後、dx/dt=1という場合も考えられます。勿論、この場合はdy/dtは2*y / xみたいな感じになります。
よろしくお願いします。
ChatGPT
線形の場合、各変数
x および y の係数を抽出するために、ASTを解析して係数を特定することができます。
以下のコードでは、数式が線形であるかどうかをチェックし、線形であれば
x と y の係数を取得するロジックを示します。

HTML
HTMLはそのままで問題ありません。

html
コードをコピーする
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Differential Equations</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.0.0/math.min.js"></script>
</head>
<body>
    <p class="pb10 input-container">
        <label id="l_dxdt">$dx / dt = $</label>
        <textarea id="dxdt" cols="30" rows="2">x^2 * (y - x) + y^5</textarea>
    </p>
    <p class="pb10 input-container">
        <label id="l_dydt">$dy / dt = $</label>
        <textarea id="dydt" cols="30" rows="2">y^2 * (y - 2 * x)</textarea>
    </p>
    <button onclick="checkLinearity()">Check Linearity</button>
    <p id="result"></p>

    <script>
        function checkLinearity() {
            const formula_dx = document.getElementById('dxdt').value;
            const formula_dy = document.getElementById('dydt').value;

            const parseCoefficients = (expr) => {
                const node = math.parse(expr);
                let linear = true;
                let coefficients = { x: 0, y: 0, constant: 0 };

                const traverse = (node) => {
                    if (node.type === 'OperatorNode') {
                        if (node.op === '+') {
                            node.args.forEach(traverse);
                        } else if (node.op === '*') {
                            if (node.args[0].type === 'ConstantNode' && node.args[1].type === 'SymbolNode') {
                                coefficients[node.args[1].name] += node.args[0].value;
                            } else if (node.args[1].type === 'ConstantNode' && node.args[0].type === 'SymbolNode') {
                                coefficients[node.args[0].name] += node.args[1].value;
                            } else {
                                linear = false;
                            }
                        } else if (node.op === '-') {
                            if (node.args.length === 2) {
                                node.args[0] = new math.OperatorNode('+', 'add', [node.args[0]]);
                                node.args[1] = new math.OperatorNode('*', 'multiply', [new math.ConstantNode(-1), node.args[1]]);
                                traverse(node);
                            } else {
                                traverse(node.args[0]);
                            }
                        } else if (node.op === '^') {
                            const base = node.args[0];
                            const exponent = node.args[1];
                            if (exponent.type === 'ConstantNode' && exponent.value === 1) {
                                traverse(base);
                            } else {
                                linear = false;
                            }
                        } else {
                            linear = false;
                        }
                    } else if (node.type === 'SymbolNode') {
                        coefficients[node.name] += 1;
                    } else if (node.type === 'ConstantNode') {
                        coefficients.constant += node.value;
                    } else if (node.type !== 'ParenthesisNode') {
                        linear = false;
                    }
                };

                traverse(node);
                return linear ? coefficients : null;
            };

            const coefficients_dx = parseCoefficients(formula_dx);
            const coefficients_dy = parseCoefficients(formula_dy);

            let resultText = '';

            if (coefficients_dx && coefficients_dy) {
                resultText = `Linear equations with coefficients:\n`;
                resultText += `dx/dt: x: ${coefficients_dx.x}, y: ${coefficients_dx.y}, constant: ${coefficients_dx.constant}\n`;
                resultText += `dy/dt: x: ${coefficients_dy.x}, y: ${coefficients_dy.y}, constant: ${coefficients_dy.constant}`;
            } else {
                resultText = 'Non-linear equations';
            }

            document.getElementById('result').innerText = resultText;
        }
    </script>
</body>
</html>
説明
関数 parseCoefficients: 入力された数式を解析し、各変数
x および y の係数を抽出します。
ASTの巡回: traverse 関数を使用してASTを再帰的に巡回し、演算子の種類に応じて係数を解析します。
加算（+）と乗算（*）の場合、適切に係数を抽出します。
減算（-）の場合、負の係数として扱います。
累乗（^）の場合、指数が1以外なら非線形としてマークします。
関数ノードやその他のノードタイプも非線形として扱います。
結果の表示: 解析結果を基に、線形方程式の係数を表示します。非線形の場合はその旨を通知します。
このコードを使えば、入力された方程式が線形の場合、
x と y の係数を取得することができます。これにより、連立微分方程式の解析やさらなる操作が容易になります。


1/2

ありがとうございます。確認してみます。
ChatGPT
どういたしまして！確認してみてください。コードがうまく動作することを願っています。
何か問題が発生したり、追加の質問があれば、遠慮なくお知らせください。引き続きサポートさせていただきます。

再度確認のため、以下に示したように、数式が線形かどうかを判定し、
線形であれば各変数の係数を抽出するための完全なコードを掲載しておきます。

完全なコード例
html
コードをコピーする
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Differential Equations</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.0.0/math.min.js"></script>
</head>
<body>
    <p class="pb10 input-container">
        <label id="l_dxdt">$dx / dt = $</label>
        <textarea id="dxdt" cols="30" rows="2">x^2 * (y - x) + y^5</textarea>
    </p>
    <p class="pb10 input-container">
        <label id="l_dydt">$dy / dt = $</label>
        <textarea id="dydt" cols="30" rows="2">y^2 * (y - 2 * x)</textarea>
    </p>
    <button onclick="checkLinearity()">Check Linearity</button>
    <p id="result"></p>

    <script>
        function checkLinearity() {
            const formula_dx = document.getElementById('dxdt').value;
            const formula_dy = document.getElementById('dydt').value;

            const parseCoefficients = (expr) => {
                const node = math.parse(expr);
                let linear = true;
                let coefficients = { x: 0, y: 0, constant: 0 };

                const traverse = (node) => {
                    if (node.type === 'OperatorNode') {
                        if (node.op === '+') {
                            node.args.forEach(traverse);
                        } else if (node.op === '*') {
                            if (node.args[0].type === 'ConstantNode' && node.args[1].type === 'SymbolNode') {
                                coefficients[node.args[1].name] += node.args[0].value;
                            } else if (node.args[1].type === 'ConstantNode' && node.args[0].type === 'SymbolNode') {
                                coefficients[node.args[0].name] += node.args[1].value;
                            } else {
                                linear = false;
                            }
                        } else if (node.op === '-') {
                            if (node.args.length === 2) {
                                node.args[0] = new math.OperatorNode('+', 'add', [node.args[0]]);
                                node.args[1] = new math.OperatorNode('*', 'multiply', [new math.ConstantNode(-1), node.args[1]]);
                                traverse(node);
                            } else {
                                traverse(node.args[0]);
                            }
                        } else if (node.op === '^') {
                            const base = node.args[0];
                            const exponent = node.args[1];
                            if (exponent.type === 'ConstantNode' && exponent.value === 1) {
                                traverse(base);
                            } else {
                                linear = false;
                            }
                        } else {
                            linear = false;
                        }
                        node.args.forEach(traverse);
                    } else if (node.type === 'SymbolNode') {
                        coefficients[node.name] += 1;
                    } else if (node.type === 'ConstantNode') {
                        coefficients.constant += node.value;
                    } else if (node.type !== 'ParenthesisNode') {
                        linear = false;
                    }
                };

                traverse(node);
                return linear ? coefficients : null;
            };

            const coefficients_dx = parseCoefficients(formula_dx);
            const coefficients_dy = parseCoefficients(formula_dy);

            let resultText = '';

            if (coefficients_dx && coefficients_dy) {
                resultText = `Linear equations with coefficients:\n`;
                resultText += `dx/dt: x: ${coefficients_dx.x}, y: ${coefficients_dx.y}, constant: ${coefficients_dx.constant}\n`;
                resultText += `dy/dt: x: ${coefficients_dy.x}, y: ${coefficients_dy.y}, constant: ${coefficients_dy.constant}`;
            } else {
                resultText = 'Non-linear equations';
            }

            document.getElementById('result').innerText = resultText;
        }
    </script>
</body>
</html>
動作確認ポイント
線形か非線形かの判定:

dx/dt = x^2 * (y - x) + y^5 は非線形なので、結果は "Non-linear equations" となるはずです。
dx/dt = x + y のような線形の例では、各係数が正しく表示されるはずです。
係数の抽出:

dx/dt = 2*x + 3*y の場合、x: 2, y: 3 と表示されるべきです。
定数項が含まれる場合も同様に正しく処理されるか確認してください。
エラーハンドリング:

非線形項が含まれる場合に適切に「Non-linear equations」と表示されることを確認してください。
確認の結果、うまく動作することを願っています。追加の質問や問題があれば、ぜひお知らせください。





最後に示して頂いたコードで確認してみました。以下の行で、RangeError: Maximum call stack size exceededが発生しました。
node.args[0] = new math.OperatorNode('+', 'add', [node.args[0]]);


ChatGPT
エラーが発生する原因は、無限再帰の可能性が高いです。この部分のコードは減算を加算に変換するために使用していますが、再帰的な構造が正しく処理されていないため、スタックオーバーフローが発生しています。

以下の改訂版では、減算を適切に処理し、無限再帰を回避するようにしました。また、係数を正しく取得するためのロジックも強化しています。


改訂版コード
html
コードをコピーする
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Differential Equations</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.0.0/math.min.js"></script>
</head>
<body>
    <p class="pb10 input-container">
        <label id="l_dxdt">$dx / dt = $</label>
        <textarea id="dxdt" cols="30" rows="2">2*x + 3*y</textarea>
    </p>
    <p class="pb10 input-container">
        <label id="l_dydt">$dy / dt = $</label>
        <textarea id="dydt" cols="30" rows="2">-x + 4*y</textarea>
    </p>
    <button onclick="checkLinearity()">Check Linearity</button>
    <p id="result"></p>

    <script>
        function checkLinearity() {
            const formula_dx = document.getElementById('dxdt').value;
            const formula_dy = document.getElementById('dydt').value;

            const parseCoefficients = (expr) => {
                const node = math.parse(expr);
                let linear = true;
                let coefficients = { x: 0, y: 0, constant: 0 };

                const traverse = (node, sign = 1) => {
                    if (node.type === 'OperatorNode') {
                        if (node.op === '+' || node.op === '-') {
                            node.args.forEach((arg, index) => {
                                traverse(arg, sign * (node.op === '-' && index === 1 ? -1 : 1));
                            });
                        } else if (node.op === '*') {
                            if (node.args[0].type === 'ConstantNode' && node.args[1].type === 'SymbolNode') {
                                coefficients[node.args[1].name] += sign * node.args[0].value;
                            } else if (node.args[1].type === 'ConstantNode' && node.args[0].type === 'SymbolNode') {
                                coefficients[node.args[0].name] += sign * node.args[1].value;
                            } else {
                                linear = false;
                            }
                        } else if (node.op === '^') {
                            const base = node.args[0];
                            const exponent = node.args[1];
                            if (!(exponent.type === 'ConstantNode' && exponent.value === 1)) {
                                linear = false;
                            }
                        } else {
                            linear = false;
                        }
                    } else if (node.type === 'SymbolNode') {
                        coefficients[node.name] += sign;
                    } else if (node.type === 'ConstantNode') {
                        coefficients.constant += sign * node.value;
                    } else {
                        linear = false;
                    }
                };

                traverse(node);
                return linear ? coefficients : null;
            };

            const coefficients_dx = parseCoefficients(formula_dx);
            const coefficients_dy = parseCoefficients(formula_dy);

            let resultText = '';

            if (coefficients_dx && coefficients_dy) {
                resultText = `Linear equations with coefficients:\n`;
                resultText += `dx/dt: x: ${coefficients_dx.x}, y: ${coefficients_dx.y}, constant: ${coefficients_dx.constant}\n`;
                resultText += `dy/dt: x: ${coefficients_dy.x}, y: ${coefficients_dy.y}, constant: ${coefficients_dy.constant}`;
            } else {
                resultText = 'Non-linear equations';
            }

            document.getElementById('result').innerText = resultText;
        }
    </script>
</body>
</html>
説明
減算の処理:

traverse関数内で、減算を適切に処理するために、演算子が - の場合、減算される項の符号を反転させて再帰呼び出しを行います。
定数項の処理:

定数項も考慮して constant フィールドに値を追加します。
線形性の判定:

非線形項が検出された場合、 linear フラグを false に設定し、処理を中止します。
この修正により、無限再帰の問題が解決され、数式の線形性を正しく判定し、係数を抽出できるようになります。ぜひ再度お試しください。何か問題があれば、またお知らせください。




確認してみました。想定されるパターンで全てOKでした。ありがとうございます。
traverse関数がよく分かりません。係数を特定するまでの流れを簡単に説明して頂けますか？


ChatGPT
もちろんです。traverse関数は、数式の抽象構文木（AST）を再帰的に巡回しながら、各変数の係数を特定するために使用します。以下に、この関数の流れを簡単に説明します。



traverse関数の流れ
関数定義: traverse(node, sign) 関数は、ASTのノード node を巡回し、そのノードが含む情報に基づいて係数を更新します。 sign は符号（正または負）を示すパラメータで、減算を処理する際に使用されます。

オペレータノードの処理:

加算（+）および減算（-）:
+ の場合、各引数（オペランド）をそのまま再帰的に処理します。
- の場合、減算される引数（第2引数）の符号を反転させて再帰的に処理します。
乗算（*）:
片方が定数で、もう片方が変数の場合、その変数の係数を更新します。
それ以外のケース（例: 変数同士の掛け算）は非線形と見なします。
累乗（^）:
累乗の指数が1の場合は無視して基底を処理しますが、それ以外の場合は非線形と見なします。
シンボルノードの処理（変数）:

変数が単独で現れる場合、その変数の係数を更新します（例えば、 x は 1*x と見なします）。
定数ノードの処理:

定数項が現れる場合、その値を定数係数に加算します。
その他のノードの処理:

その他のノード（関数ノードや予期しないノード）は非線形と見なします。
具体的な例
数式 2*x + 3*y - 4 の場合、以下のように処理されます。

数式はASTに変換されます。
traverse 関数がルートノードから呼び出されます。
ルートノードは + 演算子ノードで、その引数は 2*x と 3*y - 4 です。
2*x は * 演算子ノードで、その引数は 2 と x です。このとき、 coefficients['x'] += 2 となります。
3*y - 4 は - 演算子ノードで、その引数は 3*y と 4 です。
3*y は * 演算子ノードで、その引数は 3 と y です。このとき、 coefficients['y'] += 3 となります。
4 は定数ノードで、このとき、 coefficients['constant'] -= 4 となります（符号が反転しています）。

コードの流れ

javascript
コードをコピーする

const traverse = (node, sign = 1) => {
    if (node.type === 'OperatorNode') {
        if (node.op === '+' || node.op === '-') {
            node.args.forEach((arg, index) => {
                traverse(arg, sign * (node.op === '-' && index === 1 ? -1 : 1));
            });
        } else if (node.op === '*') {
            if (node.args[0].type === 'ConstantNode' && node.args[1].type === 'SymbolNode') {
                coefficients[node.args[1].name] += sign * node.args[0].value;
            } else if (node.args[1].type === 'ConstantNode' && node.args[0].type === 'SymbolNode') {
                coefficients[node.args[0].name] += sign * node.args[1].value;
            } else {
                linear = false;
            }
        } else if (node.op === '^') {
            const base = node.args[0];
            const exponent = node.args[1];
            if (!(exponent.type === 'ConstantNode' && exponent.value === 1)) {
                linear = false;
            }
        } else {
            linear = false;
        }
    } else if (node.type === 'SymbolNode') {
        coefficients[node.name] += sign;
    } else if (node.type === 'ConstantNode') {
        coefficients.constant += sign * node.value;
    } else {
        linear = false;
    }
};
このようにして、ASTを巡回しながら各変数の係数を特定し、線形性を判定しています。
このロジックにより、入力された数式が線形であるかどうかをチェックし、線形であればその係数を抽出することができます。










