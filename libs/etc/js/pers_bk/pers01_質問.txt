先日、曲面をメッシュで描画する方法を教えて頂きました。
それを参考にして、微分方程式の解軌道を3Dを描画するjsファイルを改造して
z = f(x, y)の曲面をプロットするプログラムを組んでいます。
これがうまくいきません。
本来、xy平面の領域を格子状に区切り、対応するzを求めてメッシュでつないでいく訳なので、
格子間の線分はそれぞれつながるはずです。
ところが、実際に描画させてみると、線分が離れて、ずれているのです。
全体的には求めたい曲面らしきものが描画されるのですが、なんちゃって状態です。

以下に、htmlとjsファイルのソースを示しました。
問題は、jsファイルのdrawGraph()内の2重ループ箇所ではないかと考えていますが、
私には特におかしな点を見つけることができませんでした。
ループ内で、3Dの(x, y, z)データをR3D()という関数で、描画アングルに従って平面に投影する処理を行っていますが、
この関数は微分方程式の解軌道3D版でも使用していて、特に問題は出ていません。

一部、不明な変数も出ていますが、行数の関係で、割愛させて頂いています。

どこに問題があるのでしょうか？
よろしくお願いします。


=== etc_Pers_v1.html ===

<!DOCTYPE HTML >
<html>

<HEAD>
    <META charset="UTF-8">

    <title>Plotting surfaces with meshes</title>

    <!-- css start -->

        <!-- kz_etc start :: class指定:change_border_color, 全ファイル共通:リンク文字色, フォーカスリング -->
        <link rel="stylesheet" href="libs/etc/css/kz_footer_style.css" type="text/css">
        <link rel="stylesheet" href="libs/etc/css/kz_etc_style.css" type="text/css">
        <!-- kz_etc end -->

    <!-- css end -->

    <!-- js start -->

     <script type="text/javascript"
          src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
        <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
            TeX: { equationNumbers: { autoNumber: "AMS" }},
            tex2jax: {
              inlineMath: [ ['$','$'], ["\\(","\\)"] ],
              processEscapes: true
            },
            "HTML-CSS": { matchFontHeight: false },
            displayAlign: "left",
            displayIndent: "2em"
          });
        </script>

    <!-- js end -->

</HEAD>

<BODY id="common-k"  onload="initialize()">

    <div id="container">

        <header>
        </header>

        <div id="main960"> <!-- page main: start -->

            <!-- title -->
            <div id="title20">
                <h3 class="pt30 pb40">
                    曲面描画
                </h3>
            </div>

            <!-- contents -->
            <div class="pic-left990 pb30">
                <div id="contents-2col-left_deq" >
                    <div id="contents-2col-left_deq" >
                        <p class="pb10">
                            <canvas id="graphCanvas" width="580" height="580"></canvas>
                        </p>
                    </div>
                    <div id="contents-2col-right_deq" >
                        <div id="vertical-slider-container">
                            <div id="vertical-slider"></div>
                        </div>
                    </div>
                    <div class="c-both"></div>
                    <div id="horizontal-slider-container">
                        <div id="horizontal-slider"></div>
                    </div>
                </div>

                <div id="contents-2col-right_deq">
                    <p class="pb10">
                        <select id="type" style="width: 220px;" onchange="changeType()">
                            <option value="01">&nbsp; 1. Lorenz system</option>
                        </select>
                    </p>
                    <!-- 描画範囲 -->
                    <div class="grid2a">
                        <div class="grid-item">
                            <p>
                                描画範囲
                            </p>
                        </div>
                        <div class="grid-item">
                            <p>
                                <input type="text" id="width0" value="5" onchange="updateRange()" style="width:50px; text-align:right;">
                                &emsp;
                                <label for="min"><span id="wmin"></span></label> $ < x, y, z < $ <label for="max"><span id="wmax"></span></label>
                            </p>
                        </div>
                    </div>

                <!-- deq javascript呼び出し -->
                <script src="libs/etc/js/pers01_v1.js" type="text/javascript"></script>

                </div>
                <div class="c-both"></div>
            </div>
        </div>

        <footer>
        </footer>
    </div>
</BODY>
</html>



=== pers01_v1.js ===

// 描画角度
let m_alpha = -20.0;   // X軸が基線と成す角
let m_gamma = -30.0;   // 基線にもっとも近い矩形の頂点を視点Eから仰ぐ角度

let vAx = 3;           // 20231010 vertical Axis(1 : x軸, 2 : y軸, 3 : z軸 ==default==)

let zValu = [];
let divisions = 16;
let step;

let width0 = 5;
let height0 = 5;

const canvas = document.getElementById('graphCanvas');
const ctx = canvas.getContext('2d');

// 描画領域をリセット
ctx.fillStyle = 'rgb( 0, 0, 0)';
ctx.fillRect(0, 0, canvas.width, canvas.height);

// スケーリング
let scaleX = canvas.width / width0;
let scaleY = canvas.height / height0;


function drawGraph() {
    // 描画領域をリセット
    ctx.fillStyle = 'rgb(0, 0, 0)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    let pixelX;
    let pixelY;
    let pixelX1;
    let pixelY1;
    let pixelX2;
    let pixelY2;

    step = width0 / divisions;
    for (let i = 0; i < divisions; i++) {
        const x = -width0 / 2 + step * i;
        zValu[i] = []; // ここで新しい行を初期化
        for (let j = 0; j < divisions; j++) {
            const y = -width0 / 2 + step * j;
            zValu[i][j] = FXY(x, y);
        };
    }

    let x, y, z;
    let nextX, nextY, zNextX, zNextY;
    for (let i = 0; i < divisions; i++) {
        for (let j = 0; j < divisions; j++) {
            x = -width0 / 2 + step * i;
            y = -width0 / 2 + step * j;
            z = zValu[i][j];
            R3D(x, y, z, obj1);

            nextX = x + step;
            nextY = y + step;

            zNextX = zValu[i + 1][j];
            zNextY = zValu[i][j + 1];
            R3D(nextX, nextY, zNextX, obj2);
            R3D(nextX, nextY, zNextY, obj3);

            pixelX = scaleX * (obj1.x3 + width0 / 2);
            pixelY = scaleY * (height0 / 2 - obj1.y3);
            pixelX1 = scaleX * (obj2.x3 + width0 / 2);
            pixelY1 = scaleY * (height0 / 2 - obj2.y3);
            pixelX2 = scaleX * (obj3.x3 + width0 / 2);
            pixelY2 = scaleY * (height0 / 2 - obj3.y3);

            ctx.beginPath();
            ctx.moveTo(pixelX, pixelY);
            ctx.lineTo(pixelX1, pixelY1);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(pixelX, pixelY);
            ctx.lineTo(pixelX2, pixelY2);
            ctx.stroke();

        };
    }
}

// 3Dデータ(計算値)を平面の画面に変換する
function R3D(x, y, z, obj)
{
    === 一部省略 ===

    switch (vAx)
    {
        case 1:
            obj.x3 = -m_RRX + z;
            obj.y3 = (-m_RRZ + x) * PERS_BASE_HEIGHT / curtHeight;
            break;
        default:
            break;
    }
    obj.z3 = 0.0;
}

function FXY(x, y) {
    let FXY;
    switch (dat)
    {
        case 1:
            FXY = (x * x +  y * y) / 5;
            return FXY;
        default:
            break;
    }
    return 0.0;
}



以下。解答など


コードを確認しました。おそらく、問題は drawGraph 関数の中で次の頂点のz値を求める際に、配列の範囲を超えている可能性があることと、描画の順序が正しくないことが原因です。

以下の修正を試してみてください：

範囲外参照の修正：
zNextX と zNextY を求める際に、配列の範囲外を参照しないように条件を追加します。

次の頂点のxとyの座標を計算する際に注意：
nextX や nextY の計算方法を変更します。

描画の順序を修正：
メッシュを正しく描画するための順序を修正します。

修正版のコードは以下の通りです：

HTML
変更なし。

JavaScript (pers01_v1.js)
javascript
コードをコピーする
// 描画角度
let m_alpha = -20.0;   // X軸が基線と成す角
let m_gamma = -30.0;   // 基線にもっとも近い矩形の頂点を視点Eから仰ぐ角度

let vAx = 3;           // 20231010 vertical Axis(1 : x軸, 2 : y軸, 3 : z軸 ==default==)

let zValu = [];
let divisions = 16;
let step;

let width0 = 5;
let height0 = 5;

const canvas = document.getElementById('graphCanvas');
const ctx = canvas.getContext('2d');

// 描画領域をリセット
ctx.fillStyle = 'rgb(0, 0, 0)';
ctx.fillRect(0, 0, canvas.width, canvas.height);

// スケーリング
let scaleX = canvas.width / width0;
let scaleY = canvas.height / height0;

function drawGraph() {
    // 描画領域をリセット
    ctx.fillStyle = 'rgb(0, 0, 0)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    let pixelX, pixelY, pixelX1, pixelY1, pixelX2, pixelY2;

    step = width0 / divisions;
    for (let i = 0; i <= divisions; i++) {
        const x = -width0 / 2 + step * i;
        zValu[i] = []; // ここで新しい行を初期化
        for (let j = 0; j <= divisions; j++) {
            const y = -width0 / 2 + step * j;
            zValu[i][j] = FXY(x, y);
        }
    }

    let x, y, z, nextX, nextY, zNextX, zNextY;
    let obj1 = {}, obj2 = {}, obj3 = {};
    for (let i = 0; i < divisions; i++) {
        for (let j = 0; j < divisions; j++) {
            x = -width0 / 2 + step * i;
            y = -width0 / 2 + step * j;
            z = zValu[i][j];
            R3D(x, y, z, obj1);

            if (i + 1 <= divisions) {
                nextX = x + step;
                zNextX = zValu[i + 1][j];
                R3D(nextX, y, zNextX, obj2);

                pixelX = scaleX * (obj1.x3 + width0 / 2);
                pixelY = scaleY * (height0 / 2 - obj1.y3);
                pixelX1 = scaleX * (obj2.x3 + width0 / 2);
                pixelY1 = scaleY * (height0 / 2 - obj2.y3);

                ctx.beginPath();
                ctx.moveTo(pixelX, pixelY);
                ctx.lineTo(pixelX1, pixelY1);
                ctx.stroke();
            }

            if (j + 1 <= divisions) {
                nextY = y + step;
                zNextY = zValu[i][j + 1];
                R3D(x, nextY, zNextY, obj3);

                pixelX = scaleX * (obj1.x3 + width0 / 2);
                pixelY = scaleY * (height0 / 2 - obj1.y3);
                pixelX2 = scaleX * (obj3.x3 + width0 / 2);
                pixelY2 = scaleY * (height0 / 2 - obj3.y3);

                ctx.beginPath();
                ctx.moveTo(pixelX, pixelY);
                ctx.lineTo(pixelX2, pixelY2);
                ctx.stroke();
            }
        }
    }
}

// 3Dデータ(計算値)を平面の画面に変換する
function R3D(x, y, z, obj) {
    // 一部省略

    switch (vAx) {
        case 1:
            obj.x3 = -m_RRX + z;
            obj.y3 = (-m_RRZ + x) * PERS_BASE_HEIGHT / curtHeight;
            break;
        default:
            break;
    }
    obj.z3 = 0.0;
}

function FXY(x, y) {
    let FXY;
    switch (dat) {
        case 1:
            FXY = (x * x + y * y) / 5;
            return FXY;
        default:
            break;
    }
    return 0.0;
}
修正点の説明
範囲外参照の修正：
配列の範囲外を参照しないように条件を追加しました。

描画の順序の修正：
次の頂点を計算する際に、nextX と nextY の計算方法を変更し、適切に隣接する頂点を描画するように修正しました。

この修正により、メッシュの描画が正しく行われるようになるはずです。試してみてください。

ありがとうございます。確認してみます。
ChatGPT
どういたしまして！確認してみてください。うまくいくことを願っています。他に質問や問題があれば、いつでもお知らせください。プロジェクトが順調に進むことを祈っています！

ありがとうございました。期待通りの描画を確認することができました。
今回の提示で、" let obj1 = {}, obj2 = {}, obj3 = {};"が加わっており、最初に示したコードに漏れがあることに気づきました。
元々、drawGraph()関数では、変数の宣言で、
    let vx1 = 0.0, vy1 = 0.0, vz1 = 0.0, vx2 = 0.0, vy2 = 0.0, vz2, vx3 = 0.0, vy3 = 0.0, vz3 = 0.0;
    let obj1 = {x3: vx1, y3: vy1, z3: vz1};
    let obj2 = {x3: vx2, y3: vy2, z3: vz2};
    let obj3 = {x3: vx3, y3: vy3, z3: vz3};
を行っていました。
これを有効活用する方法はないでしょうか？
ChatGPT
もちろんです、既存の変数宣言を有効活用することができます。 drawGraph 関数内で obj1, obj2, obj3 を再利用する方法を紹介します。

あなたの元のコードの変数宣言を有効に活用するためには、以下のように変更できます。obj1, obj2, obj3 の値を R3D 関数で更新して再利用するようにします。

修正版の JavaScript (pers01_v1.js)
javascript
コードをコピーする
// 描画角度
let m_alpha = -20.0;   // X軸が基線と成す角
let m_gamma = -30.0;   // 基線にもっとも近い矩形の頂点を視点Eから仰ぐ角度

let vAx = 3;           // 20231010 vertical Axis(1 : x軸, 2 : y軸, 3 : z軸 ==default==)

let zValu = [];
let divisions = 16;
let step;

let width0 = 5;
let height0 = 5;

const canvas = document.getElementById('graphCanvas');
const ctx = canvas.getContext('2d');

// 描画領域をリセット
ctx.fillStyle = 'rgb(0, 0, 0)';
ctx.fillRect(0, 0, canvas.width, canvas.height);

// スケーリング
let scaleX = canvas.width / width0;
let scaleY = canvas.height / height0;

function drawGraph() {
    // 描画領域をリセット
    ctx.fillStyle = 'rgb(0, 0, 0)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    let pixelX, pixelY, pixelX1, pixelY1, pixelX2, pixelY2;

    step = width0 / divisions;
    for (let i = 0; i <= divisions; i++) {
        const x = -width0 / 2 + step * i;
        zValu[i] = []; // ここで新しい行を初期化
        for (let j = 0; j <= divisions; j++) {
            const y = -width0 / 2 + step * j;
            zValu[i][j] = FXY(x, y);
        }
    }

    let x, y, z, nextX, nextY, zNextX, zNextY;
    let vx1 = 0.0, vy1 = 0.0, vz1 = 0.0, vx2 = 0.0, vy2 = 0.0, vz2, vx3 = 0.0, vy3 = 0.0, vz3 = 0.0;
    let obj1 = {x3: vx1, y3: vy1, z3: vz1};
    let obj2 = {x3: vx2, y3: vy2, z3: vz2};
    let obj3 = {x3: vx3, y3: vy3, z3: vz3};

    for (let i = 0; i < divisions; i++) {
        for (let j = 0; j < divisions; j++) {
            x = -width0 / 2 + step * i;
            y = -width0 / 2 + step * j;
            z = zValu[i][j];
            R3D(x, y, z, obj1);

            if (i + 1 <= divisions) {
                nextX = x + step;
                zNextX = zValu[i + 1][j];
                R3D(nextX, y, zNextX, obj2);

                pixelX = scaleX * (obj1.x3 + width0 / 2);
                pixelY = scaleY * (height0 / 2 - obj1.y3);
                pixelX1 = scaleX * (obj2.x3 + width0 / 2);
                pixelY1 = scaleY * (height0 / 2 - obj2.y3);

                ctx.beginPath();
                ctx.moveTo(pixelX, pixelY);
                ctx.lineTo(pixelX1, pixelY1);
                ctx.stroke();
            }

            if (j + 1 <= divisions) {
                nextY = y + step;
                zNextY = zValu[i][j + 1];
                R3D(x, nextY, zNextY, obj3);

                pixelX = scaleX * (obj1.x3 + width0 / 2);
                pixelY = scaleY * (height0 / 2 - obj1.y3);
                pixelX2 = scaleX * (obj3.x3 + width0 / 2);
                pixelY2 = scaleY * (height0 / 2 - obj3.y3);

                ctx.beginPath();
                ctx.moveTo(pixelX, pixelY);
                ctx.lineTo(pixelX2, pixelY2);
                ctx.stroke();
            }
        }
    }
}

// 3Dデータ(計算値)を平面の画面に変換する
function R3D(x, y, z, obj) {
    // 一部省略

    switch (vAx) {
        case 1:
            obj.x3 = -m_RRX + z;
            obj.y3 = (-m_RRZ + x) * PERS_BASE_HEIGHT / curtHeight;
            break;
        default:
            break;
    }
    obj.z3 = 0.0;
}

function FXY(x, y) {
    let FXY;
    switch (dat) {
        case 1:
            FXY = (x * x + y * y) / 5;
            return FXY;
        default:
            break;
    }
    return 0.0;
}
説明
変数の再利用：vx1, vy1, vz1, vx2, vy2, vz2, vx3, vy3, vz3 を obj1, obj2, obj3 に再利用し、各座標の変換結果をこれらの変数に格納するようにしています。
ループ内での変数更新：R3D 関数を呼び出す際に、obj1, obj2, obj3 の値を更新して再利用しています。
これにより、無駄な変数の初期化を避けつつ、既存のコードを有効活用できます。

ありがとうございます。これで大きく前進することができます。感謝です。
ChatGPT
メモリを更新しました
どういたしまして！問題が解決し、前進できたことを聞いて嬉しいです。引き続き、何か質問や問題があれば、いつでもお気軽にお知らせください。プロジェクトの成功をお祈りしています。

