c++で作成したプログラムをjavascriptにコンバートしたいと思っています。
以下の関数で、jsにはない「goto文」を使っている箇所があります。
これをgoto文を使わないように修正することは可能でしょうか？
よろしくお願いします。

function HLN()
{
    //  ------Hidden line---------------
    let v1;

    let eps;
    let u, v;
    let dTX, dTY;
    let KPQ;
    let dDX, dDY;
    let dXv, dYv, dZv;
    let dXvS, dYvS, dZvS;
    let dZvC;
    let dZpv;
    let IV, JV;
    let IA, JA;
    let IAV;
    let AKX, AKY;
    let KR;
    let KY;
    let KYL;
    let KXLV, KYLV;
    let KXV, KYV;
    let KXXV, KYYV;
    let K;
    let dXvv, dYvv;
    let z2;
    let KHL;
    let KX;
    let KXL;
    let JAV;

    let kpl = 1;

    if (m_lhl == 0) {
        return kpl;
    }

    eps = 0.0001;

    IV = 0; // 20230814 add
    JV = 0;

    u = m_ca - m_xp / m_el * m_sa;
    if (u == 0.0) u = 0.00001;

    v = m_xp / m_el * m_ca + m_sa;
    if (v == 0.0) v = 0.00001;

    dTX = u / v;
    dTY = v / u;

    // *******************************
    KPQ = 0;

    dDY = dTX * m_xq;
    dYv = m_yq - dDY;
    if (dYv >= -eps && dYv <= m_yw + eps) {
        IV = fix(0.9999 * m_xq / m_hxfc) + 1;

        if (m_xq < eps) IV = 0;

        JV = fix((Math.abc(dDY) + eps) / m_hyfc);

        IA = IV + 1;
        AKY = m_yq / m_hyfc;
        JA = fix(1.0001 * AKY) + 1;
        KR = 0;
        if (Math.abc(AKY - double(JA - 1)) > eps) {
            KR = 1;
        }
        KPQ = 1;
        KXV = -1;
        KYV = -1;

        if (dDY < 0.0) KYV = 1;
        if (KYV == -1) JA = JA + KR;

        v = dYv * m_ca;
    }

    dDY = dTX * (m_xw - m_xq);
    dYv = m_yq + dDY;
    if (dYv >= -eps && dYv <= m_yw + eps) {
        v1 = m_xws + dYv * m_ca;
        if (KPQ == 0 || v1 <= v) {
            IV = fix(0.9999 * (m_xw - m_xq) / m_hxfc) + 1;

            if (m_xq > m_xw - eps) IV = 0;

            JV = fix((Math.abc(dDY) + eps) / m_hyfc);
            IA = m_nx - IV;
            AKY = m_yq / m_hyfc;
            JA = fix(1.0001 * AKY) + 1;
            KR = 0;
            if (Math.abc(AKY - double(JA - 1)) > eps) {
                KR = 1;
            }
            KPQ = 1;
            KXV = 1;
            KYV = 1;

            if (dDY < 0.0) KYV = -1;
            if (KYV == -1) JA = JA + KR;

            v = v1;
        }
    }

    dDX = dTY * m_yq;
    dXv = m_xq - dDX;
    if (dXv >= -eps && dXv <= m_xw + eps) {
        v1 = dXv * m_sa;
        if (KPQ == 0 || v1 < v) {
            IV = fix((Math.abc(dDX) + eps) / m_hxfc);
            JV = fix(0.9999 * m_yq / m_hyfc) + 1;

            if (m_yq < eps) JV = 0;

            AKX = m_xq / m_hxfc;
            IA = fix(1.0001 * AKX) + 1;
            KR = 0;
            if (Math.abc(AKX - double(IA - 1)) > eps) {
                KR = 1;
            }
            JA = JV + 1;
            KPQ = 1;
            KYV = -1;
            KXV = -1;

            if (dDX < 0.0) KXV = 1;
            if (KXV == -1) IA = IA + KR;

            v = v1;
        }
    }

    dDX = dTY * (m_yw - m_yq);
    dXv = m_xq + dDX;
    if (dXv >= -eps && dXv <= m_xw + eps) {
        v1 = m_ywc + dXv * m_sa;
        if (KPQ == 0 || v1 < v) {
            IV = fix((Math.abc(dDX) + eps) / m_hxfc);
            JV = fix(0.9999 * (m_yw - m_yq) / m_hyfc) + 1;

            if (m_yq > m_yw + eps) JV = 0;

            AKX = m_xq / m_hxfc;
            IA = fix(1.0001 * AKX) + 1;
            KR = 0;
            if (Math.abc(AKX - double(IA - 1)) > eps) {
                KR = 1;
            }
            JA = m_ny - JV;
            KYV = 1;
            KXV = 1;

            if (dDX < 0.0) KXV = -1;
            if (KXV == -1) IA = IA + KR;

            v = v1;
        }
    }
    // *******************************

    if (JV < IV) {
        goto U56;
    }

    do {
        //// *******************************
        if (IV != 0) {
            dXv = m_xq;
            dYv = m_yq;
            dZv = m_zq;
            // *******************************
            for (K = 1; K < IV + 1; K++) {
                IA = IA + KXV;
                dXvS = dXv;
                dYvS = dYv;
                dXv = m_hxfc * double(IA - 1);
                dYv = m_yq + dTX * (dXv - m_xq);
                AKY = dYv / m_hyfc;
                KY = fix(1.0001 * AKY) + 1;
                KYL = KY + 1;
                dZvS = dZv;
                dYvv = m_hyfc * double(KY - 1);
                IAV = m_mpx * (IA - 1) + 1;
                KYYV = m_mpy * (KY - 1) + 1;
                KYLV = m_mpy * (KYL - 1) + 1;
                dZv = (m_alt[IAV][KYLV] - m_alt[IAV][KYYV]) * (dYv - dYvv) / m_hyfc + m_alt[IAV][KYYV];

                if (dZv > m_zMax) z2 = m_zMax;
                if (dZv < m_zMin) z2 = m_zMin;

                if (dZv > m_zMax || dZv < m_zMin) {
                    dZvC = 0.0;
                    if (z2 != dZvS) {
                        if (dZv != dZvS) {
                            dZvC = (dZv - z2) / (dZv - dZvS);
                        }
                    }
                    dXv = dXv - dZvC * (dXv - dXvS);
                    dYv = dYv - dZvC * (dYv - dYvS);
                    dZv = z2;
                }

                dZpv = ((dZv * m_zfctr + m_zc) / (dXv * m_sa + dYv * m_ca + m_et) - m_zm) * m_el;
                if (K == 1) {
                    KHL = 2;
                    if (m_zp < dZpv) KHL = 1;
                }
                else {
                    switch (KHL)
                    {
                    case 1:
                        if (m_zp > dZpv) {
                            kpl = -1;
                            return kpl;
                        }
                        break;
                    case 2:
                        if (m_zp < dZpv) {
                            kpl = -1;
                            return kpl;
                        }
                        break;
                    }
                }
            }
            // *******************************
            if (JV < IV) {
                return kpl;
            }
        }
        //// *******************************
        U56:;
        //// *******************************
        if (JV != 0) {
            dXv = m_xq;
            dYv = m_yq;
            dZv = m_zq;
            // *******************************
            for (K = 1; K < JV + 1; K++) {
                JA = JA + KYV;
                dYvS = dYv;
                dXvS = dXv;
                dYv = m_hyfc * double(JA - 1);
                dXv = m_xq + dTY * (dYv - m_yq);
                AKX = dXv / m_hxfc;
                KX = fix(1.0001 * AKX) + 1;
                KXL = KX + 1;
                dZvS = dZv;
                dXvv = m_hxfc * (KX - 1);
                JAV = m_mpy * (JA - 1) + 1;
                KXXV = m_mpx * (KX - 1) + 1;
                KXLV = m_mpx * (KXL - 1) + 1;
                dZv = (m_alt[KXLV][JAV] - m_alt[KXXV][JAV]) * (dXv - dXvv) / m_hxfc + m_alt[KXXV][JAV];

                if (dZv > m_zMax) z2 = m_zMax;
                if (dZv < m_zMin) z2 = m_zMin;

                if (dZv > m_zMax || dZv < m_zMin) {
                    dZvC = 0.0;
                    if (z2 != dZvS) {
                        if (dZv != dZvS) {
                            dZvC = (dZv - z2) / (dZv - dZvS);
                        }
                    }
                    dXv = dXv - dZvC * (dXv - dXvS);
                    dYv = dYv - dZvC * (dYv - dYvS);
                    dZv = z2;
                }

                dZpv = ((dZv * m_zfctr + m_zc) / (dXv * m_sa + dYv * m_ca + m_et) - m_zm) * m_el;
                if (K == 1) {
                    KHL = 2;
                    if (m_zp < dZpv)    KHL = 1;
                }
                else {
                    switch (KHL)
                    {
                    case 1:
                        if (m_zp > dZpv) {
                            kpl = -1;
                            return kpl;
                        }
                        break;
                    case 2:
                        if (m_zp < dZpv) {
                            kpl = -1;
                            return kpl;
                        }
                        break;
                    }
                }
            }
            // *******************************
        }
        //// *******************************
    } while (JV < IV);

    return kpl;
}


回答

goto文を使わずに関数をJavaScriptに変換する方法を考えました。
この場合、goto U56;という箇所がありますが、これは特定の条件が満たされた場合に、
指定された場所にジャンプしてループを再開する処理を行っています。

この処理を、goto文を使わない方法で実装するには、
条件に基づいて関数のフローを再構築する必要があります。以下に、goto文を使わないように修正したコードを示します。

function HLN() {
    let v1;

    let eps;
    let u, v;
    let dTX, dTY;
    let KPQ;
    let dDX, dDY;
    let dXv, dYv, dZv;
    let dXvS, dYvS, dZvS;
    let dZvC;
    let dZpv;
    let IV, JV;
    let IA, JA;
    let IAV;
    let AKX, AKY;
    let KR;
    let KY;
    let KYL;
    let KXLV, KYLV;
    let KXV, KYV;
    let KXXV, KYYV;
    let K;
    let dXvv, dYvv;
    let z2;
    let KHL;
    let KX;
    let KXL;
    let JAV;

    let kpl = 1;

    if (m_lhl == 0) {
        return kpl;
    }

    eps = 0.0001;

    IV = 0;
    JV = 0;

    u = m_ca - m_xp / m_el * m_sa;
    if (u == 0.0) u = 0.00001;

    v = m_xp / m_el * m_ca + m_sa;
    if (v == 0.0) v = 0.00001;

    dTX = u / v;
    dTY = v / u;

    KPQ = 0;

    dDY = dTX * m_xq;
    dYv = m_yq - dDY;
    if (dYv >= -eps && dYv <= m_yw + eps) {
        IV = fix(0.9999 * m_xq / m_hxfc) + 1;

        if (m_xq < eps) IV = 0;

        JV = fix((Math.abs(dDY) + eps) / m_hyfc);

        IA = IV + 1;
        AKY = m_yq / m_hyfc;
        JA = fix(1.0001 * AKY) + 1;
        KR = 0;
        if (Math.abs(AKY - (JA - 1)) > eps) {
            KR = 1;
        }
        KPQ = 1;
        KXV = -1;
        KYV = -1;

        if (dDY < 0.0) KYV = 1;
        if (KYV == -1) JA += KR;

        v = dYv * m_ca;
    }

    dDY = dTX * (m_xw - m_xq);
    dYv = m_yq + dDY;
    if (dYv >= -eps && dYv <= m_yw + eps) {
        v1 = m_xws + dYv * m_ca;
        if (KPQ == 0 || v1 <= v) {
            IV = fix(0.9999 * (m_xw - m_xq) / m_hxfc) + 1;

            if (m_xq > m_xw - eps) IV = 0;

            JV = fix((Math.abs(dDY) + eps) / m_hyfc);
            IA = m_nx - IV;
            AKY = m_yq / m_hyfc;
            JA = fix(1.0001 * AKY) + 1;
            KR = 0;
            if (Math.abs(AKY - (JA - 1)) > eps) {
                KR = 1;
            }
            KPQ = 1;
            KXV = 1;
            KYV = 1;

            if (dDY < 0.0) KYV = -1;
            if (KYV == -1) JA += KR;

            v = v1;
        }
    }

    dDX = dTY * m_yq;
    dXv = m_xq - dDX;
    if (dXv >= -eps && dXv <= m_xw + eps) {
        v1 = dXv * m_sa;
        if (KPQ == 0 || v1 < v) {
            IV = fix((Math.abs(dDX) + eps) / m_hxfc);
            JV = fix(0.9999 * m_yq / m_hyfc) + 1;

            if (m_yq < eps) JV = 0;

            AKX = m_xq / m_hxfc;
            IA = fix(1.0001 * AKX) + 1;
            KR = 0;
            if (Math.abs(AKX - (IA - 1)) > eps) {
                KR = 1;
            }
            JA = JV + 1;
            KPQ = 1;
            KYV = -1;
            KXV = -1;

            if (dDX < 0.0) KXV = 1;
            if (KXV == -1) IA += KR;

            v = v1;
        }
    }

    dDX = dTY * (m_yw - m_yq);
    dXv = m_xq + dDX;
    if (dXv >= -eps && dXv <= m_xw + eps) {
        v1 = m_ywc + dXv * m_sa;
        if (KPQ == 0 || v1 < v) {
            IV = fix((Math.abs(dDX) + eps) / m_hxfc);
            JV = fix(0.9999 * (m_yw - m_yq) / m_hyfc) + 1;

            if (m_yq > m_yw + eps) JV = 0;

            AKX = m_xq / m_hxfc;
            IA = fix(1.0001 * AKX) + 1;
            KR = 0;
            if (Math.abs(AKX - (IA - 1)) > eps) {
                KR = 1;
            }
            JA = m_ny - JV;
            KYV = 1;
            KXV = 1;

            if (dDX < 0.0) KXV = -1;
            if (KXV == -1) IA += KR;

            v = v1;
        }
    }

    while (true) {
        if (IV != 0) {
            dXv = m_xq;
            dYv = m_yq;
            dZv = m_zq;

            for (K = 1; K < IV + 1; K++) {
                IA += KXV;
                dXvS = dXv;
                dYvS = dYv;
                dXv = m_hxfc * (IA - 1);
                dYv = m_yq + dTX * (dXv - m_xq);
                AKY = dYv / m_hyfc;
                KY = fix(1.0001 * AKY) + 1;
                KYL = KY + 1;
                dZvS = dZv;
                dYvv = m_hyfc * (KY - 1);
                IAV = m_mpx * (IA - 1) + 1;
                KYYV = m_mpy * (KY - 1) + 1;
                KYLV = m_mpy * (KYL - 1) + 1;
                dZv = (m_alt[IAV][KYLV] - m_alt[IAV][KYYV]) * (dYv - dYvv) / m_hyfc + m_alt[IAV][KYYV];

                if (dZv > m_zMax) z2 = m_zMax;
                if (dZv < m_zMin) z2 = m_zMin;

                if (dZv > m_zMax || dZv < m_zMin) {
                    dZvC = 0.0;
                    if (z2 != dZvS) {
                        if (dZv != dZvS) {
                            dZvC = (dZv - z2) / (dZv - dZvS);
                        }
                    }
                    dXv = dXv - dZvC * (dXv - dXvS);
                    dYv = dYv - dZvC * (dYv - dYvS);
                    dZv = z2;
                }

                dZpv = ((dZv * m_zfctr + m_zc) / (dXv * m_sa + dYv * m_ca + m_et) - m_zm) * m_el;
                if (K == 1) {
                    KHL = 2;
                    if (m_zp < dZpv) KHL = 1;
                } else {
                    switch (KHL) {
                        case 1:
                            if (m_zp > dZpv) {
                                if (KPL1(dXvS, dYvS, dZpvS, dXv, dYv, dZpv)) {
                                    kpl = 2;
                                    return kpl;
                                }
                            }
                            break;
                        case 2:
                            if (m_zp < dZpv) {
                                if (KPL1(dXvS, dYvS, dZpvS, dXv, dYv, dZpv)) {
                                    kpl = 2;
                                    return kpl;
                                }
                            }
                            break;
                    }
                }

                dZvS = dZv;
                dXvS = dXv;
                dYvS = dYv;
                dZpvS = dZpv;
            }

            JV += KYV;
            dXvv = dXv;
            dYvv = dYv;

            if (m_xq < eps || m_xq > m_xw - eps) {
                return kpl;
            }

            if (m_yq < eps || m_yq > m_yw - eps) {
                return kpl;
            }
        }

        KXL = IV + 1;
        JAV = JV + 1;
        break;
    }

    return kpl;
}

